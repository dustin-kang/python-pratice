# 💡 Implementation (구현)
> 구현 유형의 문제는 한마디로 **피지컬을 요구하는 문제**라고도 할 수 있습니다.
> - 피지컬을 요구하는 문제? : 언어 문법에 능숙하고 코드 작성이 빠른지 요구하는 문제

예를 들어, N개의 원소가 들어있는 리스트에서 R개의 원소를 뽑아 한줄로 세울 때 `itertools`라는 순열 라이브러리를 사용하면 쉽게 짤 수 있다. 이처럼, 언어의 문법을 잘 이해한다면 해결할 수 있다.

대표적인 구현 유형으로 두가지가 있다.
#### 완전 탐색
모든 경우의 수를 주저 없이 다 계산하는 방법 [시각 문제](https://github.com/dustin-kang/Programming-Team-Notes/blob/Python/implementation/implementation.md#-시각)
#### 시뮬레이션
문제에서 제시한 알고리즘을 한단계 씩 차례대로 직접 수행하는 문제 [상하좌우 문제](https://github.com/dustin-kang/Programming-Team-Notes/blob/Python/implementation/implementation.md#-상하좌우)

## 메모리 제약 사항
>  자바나 C/C++ 언어에서는 자료형의 표현 범위 제약이 있다. 예를 들어, 2,147,438,647 보다 더 큰수를 처리하기 위해 `long long` 자료형을 사용한다. 이보다 더 큰 수를 담으려면 `BigInteger` 라이브러리를 지원하지만 이는 코딩테스트에 작성하기엔 어렵기 때문에 잘 사용하지 않는다.

파이썬에는 직접 자료형을 지정할 필요없다. 

### 리스트 고려사항
대체로 코딩 테스트에서는 128MB ~ 512MB 정도로 메모리를 제한한다. 때로는 수백만 개 이상의 데이터를 처리하는 문제가 출제된다. 
|데이터의 갯수(리스트 길이)|메모리 사용량|
|---|---|
|1,000|약 4KB|
|1,000,000 (백만)|약 4MB|
|1,000,000,000 (십억만)|약 40MB|


### 채점 환경
파이썬은 C/C++에 비해 동작속도가 2배 정도 느리다. 대체적으로 시간 제한이 1초이고 데이터의 갯수가 100만 이면 $O(NlogN)$ 이내의 시간 복잡도까지 풀어야 한다. 어느정도 시간 복잡도의 알고리즘으로 풀 수 있을 것인지 예측할 수 있어야 한다.

---

## 👨‍💻 상하좌우

|시간 제한|메모리 제한|
|--|--|
|1초|128MB|

여행가 A는 N X N 크기의 정사각형 공간 위에 서있다. 이 공간은 1 X 1 크기의 정사각형으로 나누어져 있는데 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)이다. 여행가는 상하좌우로 움직일 수 있으며 시작 좌표는 (1,1)이다. 

<img width="619" alt="image" src="https://user-images.githubusercontent.com/55238671/235070052-fb0ea2ad-d1f2-4057-98fa-eba1f3881c71.png">


- 첫째 줄에는 공간의 크기 `N`이 주어진다. 둘째 줄에는 이동 계획이 주어진다. 
- 줄을 기준으로 `L` `R` `U` `D`로 움직일 수 있다.
- 만약, 공간을 벗어나는 움직임은 무시된다. 

그렇다면 최종적으로 도착하는 위치를 출력하라.

#### 입력
```
5
R R R U D D
```
#### 출력
```
3 4
```

### 문제 풀이

```python
n = int(input())
x, y = 1, 1

directions = list(map(str, input().split()))

dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]

move_type= ['L','R','U','D']

for dir in directions:
    for i in range(len(move_type)):
        # 이동 후 좌표 구하기
        if dir == move_type[i]:
            nx = x + dx[i]
            ny = y + dy[i]
    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    x, y = nx, ny

print(x, y)
```
- 이동횟수가 N번인 경우 시간 복잡도는 $O(N)$이며 넉넉한 편입니다.
- 이러한 문제는 시뮬레이션 유형에 분류되며 구현이 중요한 문제 유형입니다. 

## 👨‍💻 시각

|시간 제한|메모리 제한|
|--|--|
|2초|128MB|

정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초 까지의 모든 시각 중에서 3이 하나라도 포함하는 모든 경우의 수를 구하는 프로그램을 작성하시오.

- 1을 입력했을 때 3이 하나라도 포함되는 시각 : 00시 00분 03초
- 3이 하나라도 포함 되어 있지 않는 시각: 01시 27분 45초


#### 입력
```
5
```
#### 출력
```
11475
```

### 문제 풀이

```python
n = int(input())
count = 0

for t in range(n+1):
    for m in range(60):
        for s in range(60):
            if '3' in str(t) + str(m) + str(s):
                count += 1
print(count)
```
- 이러한 유형은 완전 탐색 유형에 분류된다. 가능한 모든 경우를 검사해보는 방법이다.
- 일반적으로 완전 탐색 유형은 데이터 갯수가 100만 개 이하일 때 사용하면 적절하다.
- 위 문제에서는 2초 제한을 주었기 때문에 하루 86,400초를 탐색해도 100,000갯수 만큼 되지 않으므로 풀 수 있다.


---

- [실전 문제 : 왕실 나이트]()
- [실전 문제 : 게임 개발]()
